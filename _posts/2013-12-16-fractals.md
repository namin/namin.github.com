---
layout: post
title: Fractals in JavaScript
---

I recreated some fractals from
[Chapter 8 of _The Nature of Code_](http://natureofcode.com/book/chapter-8-fractals/)
using "bare-bones" JavaScript and HTML5.

For all these examples, I start by creating a canvas like this:

{% highlight html %}
    <canvas id="canvas-id" height="200"></canvas>
{% endhighlight %}

The JavaScript is enclosed in a `<script>` tag that follows the
`<canvas>` tag. Each snippet is surrounded by this boilerplate code,
which resizes the canvas width to fill the content space.

{% highlight javascript %}
    (function() {
      var content = document.getElementById("content");
      var canvas = document.getElementById("canvas-id");
      var ctx = canvas.getContext("2d");
      var W = content.offsetWidth, H = canvas.height;
      canvas.width = W;

      // snippet here
      
    })();
{% endhighlight %}

## Recursive Circles

<canvas id="canvas-rec-circles" height="200">
</canvas>
<script>
(function() {
  var content = document.getElementById("content");
  var canvas = document.getElementById("canvas-rec-circles");
  var ctx = canvas.getContext("2d");
  var W = content.offsetWidth, H = canvas.height;
  canvas.width = W;

  function drawCircle(x, y, radius) {
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(x+radius, y);
    ctx.arc(x, y, radius, 0, 2*Math.PI, false);
    ctx.lineWidth = 1;
    ctx.stroke();
    if (radius > 50) {
      drawCircle(x + radius/2, y, radius/2);
      drawCircle(x - radius/2, y, radius/2);
      drawCircle(x, y + radius/2, radius/2);
      drawCircle(x, y - radius/2, radius/2);
    }
  }
  drawCircle(W/2, H/2, W);
})();
</script>

{% highlight javascript %}
    function drawCircle(x, y, radius) {
      ctx.strokeStyle = "black";
      ctx.beginPath();
      ctx.moveTo(x+radius, y);
      ctx.arc(x, y, radius, 0, 2*Math.PI, false);
      ctx.lineWidth = 1;
      ctx.stroke();
      if (radius > 50) {
        drawCircle(x + radius/2, y, radius/2);
        drawCircle(x - radius/2, y, radius/2);
        drawCircle(x, y + radius/2, radius/2);
        drawCircle(x, y - radius/2, radius/2);
      }
    }
    drawCircle(W/2, H/2, W);
{% endhighlight %}

## Cantor Set

<canvas id="canvas-cantor-set" height="200">
</canvas>
<script>
(function() {
  var content = document.getElementById("content");
  var canvas = document.getElementById("canvas-cantor-set");
  var ctx = canvas.getContext("2d");
  var W = content.offsetWidth, H = canvas.height;
  canvas.width = W;
  
  function cantor(x, y, len)
  {
    if (len >= 1) {
      ctx.strokeStyle = "black";
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x+len, y);
      ctx.lineWidth = 5;
      ctx.stroke();
      y += 20;
      cantor(x, y, len/3);
      cantor(x+len*2/3, y, len/3);
    }
  }
  cantor(10, 10, W-20);
})();
</script>

{% highlight javascript %}
    function cantor(x, y, len)
    {
      if (len >= 1) {
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x+len, y);
        ctx.lineWidth = 5;
        ctx.stroke();
        y += 20;
        cantor(x, y, len/3);
        cantor(x+len*2/3, y, len/3);
      }
    }
    cantor(10, 10, W-20);
{% endhighlight %}

## Recursive Trees

(Click the canvas to generate a new tree.)

<canvas id="canvas-tree" height="400">
</canvas>
<script>
(function() {
  var content = document.getElementById("content");
  var canvas = document.getElementById("canvas-tree");
  var ctx = canvas.getContext("2d");
  var W = content.offsetWidth, H = canvas.height;
  canvas.width = W;
  function branch(ax, ay, len, theta, weight) {
    var bx = ax+len*Math.cos(theta)
    var by = ay-len*Math.sin(theta)
    ctx.strokeStyle = len>30 ? 'saddlebrown' : 'green';
    ctx.lineWidth = weight;
    ctx.beginPath();
    ctx.moveTo(ax, ay);
    ctx.lineTo(bx, by);
    ctx.stroke();
    if (len > 10) {
      var n = 1+Math.round(Math.random()*3);
      for (var i = 0; n > i; i++) {
        var delta = -Math.PI/2 + Math.random()*Math.PI;
        branch(bx, by, len*0.66, theta+delta, weight*0.5);
      }
    }
  }
  function init() {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, W, H);
    branch(W/2, H, H/3, Math.PI/2, 20);
  }
  init();

  canvas.addEventListener('click', init);
})();
</script>

{% highlight javascript %}
    function branch(ax, ay, len, theta, weight) {
      var bx = ax+len*Math.cos(theta)
      var by = ay-len*Math.sin(theta)
      ctx.strokeStyle = len>30 ? 'saddlebrown' : 'green';
      ctx.lineWidth = weight;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(bx, by);
      ctx.stroke();
      if (len > 10) {
        var n = 1+Math.round(Math.random()*3);
        for (var i=0; i<n; i++) {
          var delta = -Math.PI/2 + Math.random()*Math.PI;
          branch(bx, by, len*0.66, theta+delta, weight*0.5);
        }
      }
    }
    function init() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, W, H);
      branch(W/2, H, H/3, Math.PI/2, 20);
    }
    init();
    
    canvas.addEventListener('click', init);
{% endhighlight %}

## L-System Trees

<canvas id="canvas-lsys" height="400">
</canvas>
<script>
(function() {
  var content = document.getElementById("content");
  var canvas = document.getElementById("canvas-lsys");
  var ctx = canvas.getContext("2d");
  var W = content.offsetWidth, H = canvas.height;
  canvas.width = W;
  
  function Turtle(len, theta) {
    this.len = len;
    this.theta = theta;
    this.reset();
    return this;
  }
  Turtle.prototype.reset = function() {
    this.angle = Math.PI/2;
    this.p = {'x': W/2, 'y': H};
    this.stack = [];
  }
  Turtle.prototype.next = function() {
    return {'x': this.p.x+this.len*Math.cos(this.angle),
            'y': this.p.y-this.len*Math.sin(this.angle)};
  }
  Turtle.prototype.go = function() {
    var nextP = this.next();
    ctx.strokeStyle = 'black';
    ctx.beginPath();
    ctx.moveTo(this.p.x, this.p.y);
    ctx.lineTo(nextP.x, nextP.y);
    ctx.stroke();
    this.p = nextP;
  }
  Turtle.prototype.move = function() {
    this.p = this.next();
  }
  Turtle.prototype.turnLeft = function() {
    this.angle += this.theta;
  }
  Turtle.prototype.turnRight = function() {
    this.angle -= this.theta;
  }
  Turtle.prototype.push = function() {
    this.stack.push({'p': this.p, 'angle': this.angle})
  }
  Turtle.prototype.pop = function() {
    var s = this.stack.pop();
    this.p = s.p;
    this.angle = s.angle;
  }

  function LSys(axiom, rules) {
    this.sentence = axiom;
    this.rules = rules;
    return this;
  }
  LSys.prototype.generate = function() {
    var next = [];
    for (var i=0; this.sentence.length > i; i++) {
      var c = this.sentence[i];
      var r = this.rules[c];
      if (r) {
        next.push(r)
      } else {
        next.push(c);
      }
    }
    this.sentence = next.join("")
  }
  LSys.prototype.draw = function(t) {
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, W, H);
    t.reset();
    for (var i=0; this.sentence.length > i; i++) {
      var c = this.sentence[i];
      this.interpret(c, t);
    }
  }
  LSys.prototype.interpret = function(c, t) {
         if (c == 'F') t.go();
    else if (c == 'G') t.move();
    else if (c == '+') t.turnRight();
    else if (c == '-') t.turnLeft();
    else if (c == '[') t.push();
    else if (c == ']') t.pop();
  }
  var lsys = new LSys("F", {'F': "FF+[+F-F-F]-[-F+F+F]"});
  var t = new Turtle(H/4, 25*Math.PI/180);
  for (var i=0; 4 > i; i++) {
    lsys.generate();
    t.len *= 0.5;
  }
  lsys.draw(t);
})();
</script>

{% highlight javascript %}
    function Turtle(len, theta) {
      this.len = len;
      this.theta = theta;
      this.reset();
      return this;
    }
    Turtle.prototype.reset = function() {
      this.angle = Math.PI/2;
      this.p = {'x': W/2, 'y': H};
      this.stack = [];
    }
    Turtle.prototype.next = function() {
      return {'x': this.p.x+this.len*Math.cos(this.angle),
              'y': this.p.y-this.len*Math.sin(this.angle)};
    }
    Turtle.prototype.go = function() {
      var nextP = this.next();
      ctx.strokeStyle = 'black';
      ctx.beginPath();
      ctx.moveTo(this.p.x, this.p.y);
      ctx.lineTo(nextP.x, nextP.y);
      ctx.stroke();
      this.p = nextP;
    }
    Turtle.prototype.move = function() {
      this.p = this.next();
    }
    Turtle.prototype.turnLeft = function() {
      this.angle += this.theta;
    }
    Turtle.prototype.turnRight = function() {
      this.angle -= this.theta;
    }
    Turtle.prototype.push = function() {
      this.stack.push({'p': this.p, 'angle': this.angle})
    }
    Turtle.prototype.pop = function() {
      var s = this.stack.pop();
      this.p = s.p;
      this.angle = s.angle;
    }
  
    function LSys(axiom, rules) {
      this.sentence = axiom;
      this.rules = rules;
      return this;
    }
    LSys.prototype.generate = function() {
      var next = [];
      for (var i=0; i<this.sentence.length; i++) {
        var c = this.sentence[i];
        var r = this.rules[c];
        if (r) {
          next.push(r)
        } else {
          next.push(c);
        }
      }
      this.sentence = next.join("")
    }
    LSys.prototype.draw = function(t) {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, W, H);
      t.reset();
      for (var i=0; i<this.sentence.length; i++) {
        var c = this.sentence[i];
        this.interpret(c, t);
      }
    }
    LSys.prototype.interpret = function(c, t) {
           if (c == 'F') t.go();
      else if (c == 'G') t.move();
      else if (c == '+') t.turnRight();
      else if (c == '-') t.turnLeft();
      else if (c == '[') t.push();
      else if (c == ']') t.pop();
    }
    var lsys = new LSys("F", {'F': "FF+[+F-F-F]-[-F+F+F]"});
    var t = new Turtle(H/4, 25*Math.PI/180);
    for (var i=0; i<4; i++) {
      lsys.generate();
      t.len *= 0.5;
    }
    lsys.draw(t);
{% endhighlight %}
